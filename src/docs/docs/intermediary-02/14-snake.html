
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>Mini projeto * Snake Game · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.7.1">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="13-tests.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Sobre</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introdução
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Capítulos</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../basic/">
            
                <a href="../basic/">
            
                    
                    Basico
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../basic/01-about.html">
            
                <a href="../basic/01-about.html">
            
                    
                    Sobre a linguagem
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../basic/02-environment.html">
            
                <a href="../basic/02-environment.html">
            
                    
                    Ambiente
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="../basic/03-hello-world.html">
            
                <a href="../basic/03-hello-world.html">
            
                    
                    Hello World
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.4" data-path="../basic/04-data-types.html">
            
                <a href="../basic/04-data-types.html">
            
                    
                    Tipos de dados
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.5" data-path="../basic/05-operators.html">
            
                <a href="../basic/05-operators.html">
            
                    
                    Operadores
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.6" data-path="../basic/06-conditions.html">
            
                <a href="../basic/06-conditions.html">
            
                    
                    Condicionais
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.7" data-path="../basic/07-loops.html">
            
                <a href="../basic/07-loops.html">
            
                    
                    Loops
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.8" data-path="../basic/08-functions.html">
            
                <a href="../basic/08-functions.html">
            
                    
                    Funções
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.9" data-path="../basic/09-arrays.html">
            
                <a href="../basic/09-arrays.html">
            
                    
                    Arrays
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.10" data-path="../basic/10-exercises.html">
            
                <a href="../basic/10-exercises.html">
            
                    
                    Exercícios
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../intermediary-01/">
            
                <a href="../intermediary-01/">
            
                    
                    Intermediario 1
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.2.1" data-path="../intermediary-01/01-strings.html">
            
                <a href="../intermediary-01/01-strings.html">
            
                    
                    Strings
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.2" data-path="../intermediary-01/02-pointers-intro.html">
            
                <a href="../intermediary-01/02-pointers-intro.html">
            
                    
                    Introdução a ponteiros
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.3" data-path="../intermediary-01/03-ownership.html">
            
                <a href="../intermediary-01/03-ownership.html">
            
                    
                    Ownership
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.4" data-path="../intermediary-01/04-tuples.html">
            
                <a href="../intermediary-01/04-tuples.html">
            
                    
                    Tuplas
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.5" data-path="../intermediary-01/05-slices.html">
            
                <a href="../intermediary-01/05-slices.html">
            
                    
                    Slices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.6" data-path="../intermediary-01/06-user-input.html">
            
                <a href="../intermediary-01/06-user-input.html">
            
                    
                    Entrada de dados
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2.7" data-path="../intermediary-01/07-exercises.html">
            
                <a href="../intermediary-01/07-exercises.html">
            
                    
                    Exercicios
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="./">
            
                <a href="./">
            
                    
                    Intermediario 2
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.3.1" data-path="01-structs.html">
            
                <a href="01-structs.html">
            
                    
                    Struct
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.2" data-path="02-enums.html">
            
                <a href="02-enums.html">
            
                    
                    Enum
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.3" data-path="03-match.html">
            
                <a href="03-match.html">
            
                    
                    Match
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.4" data-path="04-modules.html">
            
                <a href="04-modules.html">
            
                    
                    Modulos
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.5" data-path="05-generics.html">
            
                <a href="05-generics.html">
            
                    
                    Generics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.6" data-path="06-traits.html">
            
                <a href="06-traits.html">
            
                    
                    Traits
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.7" data-path="07-option.html">
            
                <a href="07-option.html">
            
                    
                    Enum especial Option
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.8" data-path="08-vec.html">
            
                <a href="08-vec.html">
            
                    
                    Coleções: Vec
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.9" data-path="09-hashset.html">
            
                <a href="09-hashset.html">
            
                    
                    Coleções: HashSet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.10" data-path="10-hashmap.html">
            
                <a href="10-hashmap.html">
            
                    
                    Coleções: HashMap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.11" data-path="11-result.html">
            
                <a href="11-result.html">
            
                    
                    Tratamento de erros
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.12" data-path="12-panic.html">
            
                <a href="12-panic.html">
            
                    
                    Macro panic!
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.13" data-path="13-tests.html">
            
                <a href="13-tests.html">
            
                    
                    Testes
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.3.14" data-path="14-snake.html">
            
                <a href="14-snake.html">
            
                    
                    Mini projeto * Snake Game
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Mini projeto * Snake Game</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="snake-game">Snake Game</h1>
<p>Eu estava em dúvida em que projeto fazer neste ponto, foi difícil pensar em algo e, porque não  algo que eu nunca fiz?</p>
<p>Então vamos lá fazer o &quot;jogo da cobrinha&quot;, vamos começar criando o projeto, usando o comando <code>cargo new snake-game</code>.</p>
<p>Teremos a estrutura padrão do projeto:</p>
<pre><code class="lang-bash">├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>Vamos adicionar um arquivo chamado <code>lib.rs</code> na pasta <code>src</code>, este arquivo sera usado para declarar os nossos módulos. Em seguida criamos um arquivo chamado &quot;ponto.rs&quot; e nele iremos criar uma <a href="01-structs.html">struct</a> para as localizações no nosso jogo, vamos criar uma implementação a essa struct para facilitar a instanciação dessa <code>strutc</code>.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ponto</span></span> {
    <span class="hljs-keyword">pub</span> x: <span class="hljs-built_in">usize</span>,
    <span class="hljs-keyword">pub</span> y: <span class="hljs-built_in">usize</span>
}

<span class="hljs-keyword">impl</span> Ponto {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(x: <span class="hljs-built_in">usize</span>, y: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            x,
            y
        }
    }
}
</code></pre>
<p>Para que este arquivo seja reconhecido no projeto, vamos adicionar no nosso arquivo <code>lib.rs</code> a seguinte linha <code>pub mod point;</code>. Note que tanto a <code>struct</code> quanto seus atributos e a implementação do método <code>new</code> estão com a palavra <code>pub</code>, que faz eles serem visíveis fora desse módulo.</p>
<p>Vamos printar o campo onde a cobrinha ira andar, e para testar vamos adicionar um ponto nesse tabuleiro.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> ponto = Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);
    <span class="hljs-keyword">let</span> (x, y) = (<span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..x {
        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..y {
            <span class="hljs-keyword">if</span> ponto == (x, y) {
                <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;# &quot;</span>)
            }  <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;- &quot;</span>);   
            }
        }
        <span class="hljs-built_in">println!</span>();
    }
}
</code></pre>
<p>Note que comparamos a nossa <code>struct</code> Ponto, com uma tupla de (x, y), para isso ser possível, precisamos implementar uma <a href="06-traits.html">trait</a> chamada <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" target="_blank">PartialEq</a> a implementação para isso é relativamente simples. A <code>trait</code> recebe um parâmetro <a href="05-generics.html">genérico</a> na implementação vamos falar que esse parâmetro genérico é uma <code>tupla (usize, usize)</code>. E a partir dai implementamos nossa comparação.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">impl</span> <span class="hljs-built_in">PartialEq</span>&lt;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)&gt; <span class="hljs-keyword">for</span> Ponto {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eq</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)) -&gt; <span class="hljs-built_in">bool</span> {
        <span class="hljs-keyword">self</span>.x == other.<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">self</span>.y == other.<span class="hljs-number">1</span>
    }
}
</code></pre>
<p>Agora quando rodarmos o projeto com <code>cargo run</code>, teremos um tabuleiro no console com um ponto na posição (7, 7).</p>
<pre><code class="lang-bash">   Compiling snake-game v0.1.0 (/home/paulo.bezerra/workspace/ws-rust/rust4noobs/projects/snake-game)
    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.31s
     Running `target/debug/snake-game`
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - <span class="hljs-comment"># - - - - - - - </span>
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - -
</code></pre>
<p>Agora vamos criar a <code>struct</code> da nossa cobrinha, para isso vamos adicionar a cabeça - que é um ponto - e uma lista de pontos para o corpo. Criamos o arquivo &quot;cobra.rs&quot; e adicionamos o <code>pub mod cobra</code> no arquivo <code>lib.rs</code>, e no arquivo &quot;cobra.rs&quot; adicionamos a struct.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cobra</span></span> {
    <span class="hljs-keyword">pub</span> cabeca: Ponto,
    <span class="hljs-keyword">pub</span> corpo: <span class="hljs-built_in">Vec</span>&lt;Ponto&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Cobra {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> { 
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), 
            corpo: <span class="hljs-built_in">vec!</span>[Ponto::new(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>), Ponto::new(<span class="hljs-number">5</span>,<span class="hljs-number">7</span>)]
        }
    }
}
</code></pre>
<p>A implementação da <code>trait</code> <a href="https://doc.rust-lang.org/std/default/trait.Default.html" target="_blank">default</a> serve para termos um valor padrão para a <code>struct</code>. Vamos separar a nossa função de desenhar o tabuleiro e vamos passar uma referência para a <code>struct</code> da <code>cobra</code>, então com base nos dados passados ali vamos desenhar a nossa cobra.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_board</span></span>(cobra: &amp;Cobra) {
    <span class="hljs-keyword">let</span> (x, y) = (<span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..y {
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..x {
            <span class="hljs-keyword">if</span> cobra.cabeca == (x, y) {
                <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;0 &quot;</span>)
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cobra.corpo.contains(&amp;Ponto::new(x, y)) {
                <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;# &quot;</span>);   
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;- &quot;</span>);   
            }
        }
        <span class="hljs-built_in">println!</span>();
    }
}
</code></pre>
<p>Temos a função e agora é só chamar ela na nossa função <code>main</code>.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    print_board(&amp;Cobra::default())
}
</code></pre>
<p>Após executar o comando <code>cargo run</code> temos o output:</p>
<pre><code class="lang-bash">    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.00s
     Running `target/debug/snake-game`
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - <span class="hljs-comment"># # 0 - - - - - - - </span>
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - -
</code></pre>
<p>Agora temos a cabeça e o corpo, precismos começar a definir uma direção que a cobra irá seguir e movimentar o corpo da cobra.</p>
<p>Para isso criamos um enumarado de direções, seguimos o mesmo passo a passo, criamos um arquivo &quot;direcao.rs&quot; e adicionamos no arquivo <code>lib.rs</code> a declaração do módulo <code>pub mob direcao</code>.</p>
<p>Então adicionamos as 4 direções possíveis ao nosso enum.</p>
<pre><code class="lang-rust"><span class="hljs-meta">#[derive(Clone, Copy)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Direcao</span></span> {
    Cima,
    Baixo,
    Direita,
    Esquerda,
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Direcao {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        Self::Direita
    }
}
</code></pre>
<p>Criamos o enum já implementando a <code>trait default</code> para nos auxiliar, como o padrão de início da cobra sempre vai ser para a direita, colocamos o retorno do método o valor <code>Self::Direita</code>. Já derivamos as <code>traits</code>, <code>Clone</code> e <code>Copy</code> para não precisar passar esse enum como referência todas às vezes.</p>
<p>Agora na nossa <code>struct</code> da cobra, vamos adicionar o atributo da direção.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cobra</span></span> {
    <span class="hljs-keyword">pub</span> cabeca: Ponto,
    <span class="hljs-keyword">pub</span> corpo: <span class="hljs-built_in">Vec</span>&lt;Ponto&gt;,
    direcao: Direcao
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Cobra {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> { 
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), 
            corpo: <span class="hljs-built_in">vec!</span>[Ponto::new(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>), Ponto::new(<span class="hljs-number">5</span>,<span class="hljs-number">7</span>)],
            direcao: <span class="hljs-built_in">Default</span>::default() 
        }
    }
}
</code></pre>
<p>Agora temos um modo de saber para qual direção a cobra está andando.</p>
<p>Na nossa <code>struct Ponto</code> vamos adicionar a função para alterar o valor do ponto.</p>
<pre><code class="lang-rust">
<span class="hljs-keyword">impl</span> Point {
   ...

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alterar</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, direcao: Direcao) {
        <span class="hljs-keyword">match</span> Direcao {
            Direcao::Right =&gt; <span class="hljs-keyword">self</span>.x += <span class="hljs-number">1</span>,
            Direcao::Left =&gt; <span class="hljs-keyword">self</span>.x -= <span class="hljs-number">1</span>,
            Direcao::Up =&gt; <span class="hljs-keyword">self</span>.y -= <span class="hljs-number">1</span>,
            Direcao::Down =&gt; <span class="hljs-keyword">self</span>.y += <span class="hljs-number">1</span>,
        }
    }
}
</code></pre>
<p>Vamos aproveitar e adicionar testes unitários para o método de alterar:</p>
<pre><code class="lang-rust"><span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> ponto_tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alterar_para_cima</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ponto = Ponto::new(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
        ponto.alterar(Direcao::Cima);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), ponto);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alterar_para_baixo</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ponto = Ponto::new(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
        ponto.alterar(Direcao::Baixo);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), ponto);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alterar_para_direita</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ponto = Ponto::new(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
        ponto.alterar(Direcao::Direita);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), ponto);
    }


    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alterar_para_esquerda</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ponto = Ponto::new(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
        ponto.alterar(Direcao::Esquerda);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), ponto);
    }

}
</code></pre>
<p>Agora iremos adicionar a lógica para a cobra se mover, precisaremos de um método para mover a cabeça que é quem vai definir se o movimento é valido, se vai bater na parede, se vamos alterar a direção e já vamos adicionar os testes que consiste em, encerrar o jogo caso bata na parede, validar a posição dos pontos após algum movimento, etc.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">impl</span> Cobra {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">passo</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, tabuleiro: (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)) -&gt; <span class="hljs-built_in">Result</span>&lt;(), &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-built_in">str</span>&gt; {
        <span class="hljs-keyword">let</span> posicao_anterior_cabeca = <span class="hljs-keyword">self</span>.cabeca;
        <span class="hljs-keyword">self</span>.mover_cabeca(&amp;tabuleiro)?;
        <span class="hljs-keyword">self</span>.mover_corpo(posicao_anterior_cabeca);
        <span class="hljs-literal">Ok</span>(())
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alterar_direcao</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, direcao: Direcao) {
        <span class="hljs-keyword">self</span>.direcao = direcao;
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, board: &amp;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)) -&gt; <span class="hljs-built_in">Result</span>&lt;(), &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-built_in">str</span>&gt; {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.direcao {
            Direcao::Cima <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.y == <span class="hljs-number">0</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede de cima&quot;</span>),
            Direcao::Baixo <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.y &gt;= board.<span class="hljs-number">1</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede de baixo&quot;</span>),
            Direcao::Esquerda <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.x == <span class="hljs-number">0</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede da esquerda&quot;</span>),
            Direcao::Direita <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.x &gt;= board.<span class="hljs-number">0</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede da direita&quot;</span>),
            _ =&gt; {
                <span class="hljs-keyword">self</span>.cabeca.alterar(<span class="hljs-keyword">self</span>.direcao);
                <span class="hljs-literal">Ok</span>(())
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_corpo</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, posicao_anterior_cabeca: Ponto) {
        <span class="hljs-keyword">let</span> corpo = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.corpo;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> posicao_anterior = posicao_anterior_cabeca;
        <span class="hljs-keyword">for</span> ponto <span class="hljs-keyword">in</span> corpo.iter_mut() {
            std::mem::swap(&amp;<span class="hljs-keyword">mut</span> posicao_anterior, ponto);
        }
    }
}

...

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> cobra_tests {

    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_direita_no_tabuleiro_deve_mover_com_sucesso</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Right,
        };
        <span class="hljs-keyword">let</span> expected_point = Ponto::new(<span class="hljs-number">8</span>, <span class="hljs-number">7</span>);
        cobra.mover_cabeca(&amp;(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>)).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(expected_point, cobra.cabeca);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_esquerda_no_tabuleiro_deve_mover_com_sucesso</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Left,
        };
        <span class="hljs-keyword">let</span> expected_point = Ponto::new(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>);
        cobra.mover_cabeca(&amp;(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>)).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(expected_point, cobra.cabeca);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_cima_no_tabuleiro_deve_mover_com_sucesso</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Up,
        };
        <span class="hljs-keyword">let</span> expected_point = Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">6</span>);
        cobra.mover_cabeca(&amp;(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>)).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(expected_point, cobra.cabeca);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_baixo_no_tabuleiro_deve_mover_com_sucesso</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Down,
        };
        <span class="hljs-keyword">let</span> expected_point = Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>);
        cobra.mover_cabeca(&amp;(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>)).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(expected_point, cobra.cabeca);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-meta-string">&quot;fim de jogo, esbarrou na parede da direita&quot;</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_direita_no_tabuleiro_deve_esbarrar_na_parede</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Right,
        };
        cobra.mover_cabeca(&amp;(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>)).unwrap();
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-meta-string">&quot;fim de jogo, esbarrou na parede da esquerda&quot;</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_esquerda_no_tabuleiro_deve_esbarrar_na_parede</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Left,
        };
        cobra.mover_cabeca(&amp;(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>)).unwrap();
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-meta-string">&quot;fim de jogo, esbarrou na parede de baixo&quot;</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_baixo_no_tabuleiro_deve_esbarrar_na_parede</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Down,
        };
        cobra.mover_cabeca(&amp;(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>)).unwrap();
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-meta-string">&quot;fim de jogo, esbarrou na parede de cima&quot;</span>)]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca_cobra_para_cima_no_tabuleiro_deve_esbarrar_na_parede</span></span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),
            corpo: <span class="hljs-built_in">vec!</span>[],
            direcao: Direcao::Up,
        };
        cobra.mover_cabeca(&amp;(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>)).unwrap();
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cobra_inteira_para_a_direita_deve_mover</span></span>() {
        <span class="hljs-keyword">let</span> tabuleiro = (<span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[Ponto::new(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)],
            direcao: Direcao::Right,
        };
        cobra.passo(board).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">8</span>, <span class="hljs-number">7</span>), cobra.cabeca);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), *cobra.corpo.first().unwrap());
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cobra_inteira_para_a_esquerda_deve_mover</span></span>() {
        <span class="hljs-keyword">let</span> tabuleiro = (<span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[Ponto::new(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)],
            direcao: Direcao::Left,
        };
        cobra.passo(board).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>), cobra.cabeca);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), *cobra.corpo.first().unwrap());
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cobra_inteira_para_cima_deve_mover</span></span>() {
        <span class="hljs-keyword">let</span> tabuleiro = (<span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[Ponto::new(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)],
            direcao: Direcao::Up,
        };
        cobra.passo(board).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">6</span>), cobra.cabeca);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), *cobra.corpo.first().unwrap());
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cobra_inteira_para_baixo_deve_mover</span></span>() {
        <span class="hljs-keyword">let</span> tabuleiro = (<span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra = Cobra {
            cabeca: Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>),
            corpo: <span class="hljs-built_in">vec!</span>[Ponto::new(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)],
            direcao: Direcao::Down,
        };
        cobra.passo(board).unwrap();
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>), cobra.cabeca);
        <span class="hljs-built_in">assert_eq!</span>(Ponto::new(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), *cobra.corpo.first().unwrap());
    }
}
</code></pre>
<p>Notem o método de mover a cabeça da cobra:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_cabeca</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, board: &amp;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)) -&gt; <span class="hljs-built_in">Result</span>&lt;(), &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-built_in">str</span>&gt; {
    <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.direcao {
        Direcao::Cima <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.y == <span class="hljs-number">0</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede de cima&quot;</span>),
        Direcao::Baixo <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.y &gt;= board.<span class="hljs-number">1</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede de baixo&quot;</span>),
        Direcao::Esquerda <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.x == <span class="hljs-number">0</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede da esquerda&quot;</span>),
        Direcao::Direita <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cabeca.x &gt;= board.<span class="hljs-number">0</span> =&gt; <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, esbarrou na parede da direita&quot;</span>),
        _ =&gt; {
            <span class="hljs-keyword">self</span>.cabeca.alterar(<span class="hljs-keyword">self</span>.direcao);
            <span class="hljs-literal">Ok</span>(())
        }
    }
}
</code></pre>
<p>Temos nessa implementação o uso de um <code>if</code> que segue o valor do <a href="02-enums.html">enum</a>, afinal o que é isso?</p>
<p>Isso faz parte do <a href="03-match.html">Pattern Match</a>, é algo que chamamos de <a href="https://doc.rust-lang.org/rust-by-example/flow_control/match/guard.html" target="_blank">guards</a>, do modo em que essa implementação é feita, temos duas validações para cair nesse ponto, o <code>enum</code> deve bater ali e a condição deve ser verdadeira, caso uma das duas condições falhe ele segue para o próximo <code>match</code>.</p>
<p>Na função de mover o corpo temos a lógica para mover o restante da cobra, guardamos a posição do ponto antes de ser alterada e fazemos o próximo item a ser iterado a obter essa posição. Para isso usamos o método da biblioteca padrão do Rust, <code>swap</code>, esse método troca o valor de duas referencias que são passadas.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">mover_corpo</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, posicao_anterior_cabeca: Ponto) {
    <span class="hljs-keyword">let</span> corpo = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.corpo;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> posicao_anterior = posicao_anterior_cabeca;
    <span class="hljs-keyword">for</span> ponto <span class="hljs-keyword">in</span> corpo.iter_mut() {
        std::mem::swap(&amp;<span class="hljs-keyword">mut</span> posicao_anterior, ponto);
    }
}
</code></pre>
<p>Agora temos a lógica de mover a cobra, mas temos um problema nela, no método de alterar a direção, não temos uma validação para saber se o jogador, selecionou a opção de direção contraria da que a cobra esta seguindo, vamos adicionar agora.</p>
<p>No nosso enum de direção, vamos adicionar um método para pegar a direção contraria.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">impl</span> Direcao {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">direcao_inversa</span></span>(outro: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">match</span> outro {
            Self::Cima =&gt; Self::Baixo,
            Self::Baixo =&gt; Self::Cima,
            Self::Direita =&gt; Self::Esquerda,
            Self::Esquerda =&gt; Self::Direita
        }
    }
}
</code></pre>
<p>Deixo o teste deste método por sua conta.</p>
<p>E agora no nosso método de alterar a direção, faremos a validação, também deixo por sua conta esta alteração, e os testes da mesma.</p>
<p>Agora que temos o tabuleiro do jogo sendo desenhado, e temos a movimentação da cobra programada, vamos adicionar o petisco que iremos ter que pegar no jogo. O petisco é um ponto, então não precisamos criar outra <code>struct</code> para ela, apenas vamos gerar um ponto aleatório e fazer o nosso render renderiza-lo.</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gerar_petisco</span></span>(cobra: &amp;Cobra, tabuleiro: &amp;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)) -&gt; Point {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> petisco;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> x = rand::thread_rng().gen_range(<span class="hljs-number">0</span>..=tabuleiro.<span class="hljs-number">0</span> - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">let</span> y = rand::thread_rng().gen_range(<span class="hljs-number">0</span>..=tabuleiro.<span class="hljs-number">1</span> - <span class="hljs-number">1</span>);
        petisco = Point::new(x, y);
        <span class="hljs-keyword">if</span> cobra.cabeca != petisco &amp;&amp; !cobra.corpo.contains(&amp;petisco) {
            <span class="hljs-keyword">break</span>;
        }
    }
    petisco
}
</code></pre>
<p>Para esse <a href="https://crates.io/crates/rand" target="_blank">rand</a> funcionar precisamos ir em nosso Cargo.toml e adicionar a seguinte dependência <code>rand = &quot;0.8.5&quot;</code> logo abaixo do <code>[dependencies]</code>, nesse método temos validações para não gerar um petisco em cima da cobra, ou seja, se o valor aleatório cair na cabeça ou em alguma parte do corpo da cobra, outro valor sera gerado. Quando o valor respeitar essa condição o <code>loop</code> para.</p>
<p>Agora precisamos aumentar o tamanho da cobra, para isso adicionamos um método que ira adicionar um ponto, no fim do corpo da cobra.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">impl</span> Cobra
    ...
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">aumentar_tamanho</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> ultimo = <span class="hljs-keyword">self</span>.body.last().unwrap().clone();
        <span class="hljs-keyword">self</span>.body.push(ultimo);
    }

}
</code></pre>
<p>Para testar esse método é interessante, validarmos o tamanho do corpo e se a posição do ponto adicionado, é igual à posição do último ponto anterior após a cobra se mover.</p>
<p>Agora temos que fazer o jogo funcionar, estamos quase lá.</p>
<p>Vamos criar um arquivo <code>jogo</code> onde teremos a <code>struct Jogo</code>. Aquele mesmo processo de sempre, cria o arquivo, adiciona na <code>lib.rs</code>.</p>
<p>A struct é a mais simples possível, ela é apenas.</p>
<pre><code class="lang-rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Jogo</span></span>;
</code></pre>
<p>Então vamos alterar o método que desenha o tabuleiro para gerar uma <a href="../intermediary-01/01-strings.html">String</a>, vamos usa-la para desenhar o tabuleiro inteiro de uma vez e também vamos movê-la para a <code>struct Jogo</code>.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">impl</span> Jogo {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gerar_tabuleuro</span></span>(cobra: &amp;Cobra, petisco: &amp;Ponto, tabuleiro: &amp;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buffer = <span class="hljs-built_in">String</span>::new();
        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..tabuleiro.<span class="hljs-number">1</span> {
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..tabuleiro.<span class="hljs-number">0</span> {
                <span class="hljs-keyword">if</span> cobra.cabeca == (x, y) {
                    buffer.push_str(<span class="hljs-string">&quot;0 &quot;</span>)
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cobra.corpo.contains(&amp;Ponto::new(x, y)) {
                    buffer.push_str(<span class="hljs-string">&quot;# &quot;</span>);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> *petisco == (<span class="hljs-number">1</span>x, y) {
                    buffer.push_str(<span class="hljs-string">&quot;+ &quot;</span>);
                } <span class="hljs-keyword">else</span> {
                    buffer.push_str(<span class="hljs-string">&quot;- &quot;</span>);
                }
            }
            buffer.push(<span class="hljs-string">&apos;\n&apos;</span>);
        }
        buffer
    }
}
</code></pre>
<p>Agora que fizemos essa alteração, vamos jogar o gerador do petisco para essa mesma struct.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">impl</span> Jogo {
    ...
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gerar_petisco</span></span>(cobra: &amp;Cobra, tabuleiro: &amp;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)) -&gt; Point {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> petisco;
        <span class="hljs-keyword">loop</span> {
            <span class="hljs-keyword">let</span> x = rand::thread_rng().gen_range(<span class="hljs-number">0</span>..=tabuleiro.<span class="hljs-number">0</span> - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">let</span> y = rand::thread_rng().gen_range(<span class="hljs-number">0</span>..=tabuleiro.<span class="hljs-number">1</span> - <span class="hljs-number">1</span>);
            petisco = Point::new(x, y);
            <span class="hljs-keyword">if</span> cobra.cabeca != petisco &amp;&amp; !cobra.corpo.contains(&amp;petisco) {
                <span class="hljs-keyword">break</span>;
            }
        }
        petisco
    }
}
</code></pre>
<p>E estamos quase lá, falta apenas um loop infinito, onde, movemos a cobra, limpamos a tela anterior, redesenhamos a tela e capturamos a tecla acionada.
Para facilitar o processo vamos adicionar mais uma dependência no arquivo <code>Cargo.toml</code>, sera dependência <a href="https://crates.io/crates/termion" target="_blank">termion</a>.</p>
<p>Então nosso arquivo ficará parecido com isso:</p>
<pre><code class="lang-toml"><span class="hljs-section">[package]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">&quot;snake-game&quot;</span>
<span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span>
<span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span>

<span class="hljs-section">[dependencies]</span>

<span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.8.5&quot;</span>
<span class="hljs-attr">termion</span> = <span class="hljs-string">&quot;1.5.6&quot;</span>
</code></pre>
<p>Vamos adicionar o método estático na <code>struct Jogo</code> que ira fazer a &quot;mágica&quot; acontecer.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">impl</span> Jogo {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), &amp;<span class="hljs-symbol">&apos;static</span> <span class="hljs-built_in">str</span>&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cobra: Cobra = <span class="hljs-built_in">Default</span>::default();
        <span class="hljs-keyword">let</span> tabuleiro = (<span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> petisco = Self::gerar_petisco(&amp;snake, &amp;tabuleiro);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stdin = termion::async_stdin().keys();
        <span class="hljs-keyword">loop</span> {
            <span class="hljs-keyword">if</span> cobra.cabeca == snack {
                cobra.aumentar_tamanho();
                petisco = Self::gerar_petisco(&amp;cobra, &amp;tabuleiro);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cobra.corpo.contains(&amp;cobra.cabeca) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(<span class="hljs-string">&quot;fim de jogo, a cobra bateu nela mesma&quot;</span>);
            }
            <span class="hljs-keyword">let</span> tabuleiro_jogo = Self::gerar_tabuleuro(&amp;cobra, &amp;petisco, &amp;tabuleiro);
            <span class="hljs-built_in">print!</span>(
                <span class="hljs-string">&quot;{}{}{}&quot;</span>,
                termion::clear::All,
                termion::cursor::Goto(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),
                termion::cursor::Hide
            );
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, tabuleiro_jogo);
            <span class="hljs-keyword">let</span> stdout = io::stdout().into_raw_mode().unwrap();
            <span class="hljs-keyword">let</span> input = stdin.next();
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-literal">Ok</span>(key)) = input {
                <span class="hljs-keyword">match</span> key {
                    Key::Char(<span class="hljs-string">&apos;a&apos;</span>) | Key::Left =&gt; cobra.alterar_direcao(Direcao::Esquerda),
                    Key::Char(<span class="hljs-string">&apos;w&apos;</span>) | Key::Up =&gt; cobra.alterar_direcao(Direcao::Cima),
                    Key::Char(<span class="hljs-string">&apos;s&apos;</span>) | Key::Down =&gt; cobra.alterar_direcao(Direcao::Baixo),
                    Key::Char(<span class="hljs-string">&apos;d&apos;</span>) | Key::Right =&gt; cobra.alterar_direcao(Direcao::Direita),
                    _ =&gt; {},
                }
            }
            stdout.lock().flush().unwrap();
            thread::sleep(Duration::from_millis(<span class="hljs-number">500</span>));
            cobra.passo(tabuleiro)?;
        }
    }
}
</code></pre>
<p>Esse método agrupa tudo o que nós precisamos, criamos a cobra, criamos o primeiro petisco, definimos o tamanho do tabuleiro e começamos a trabalhar.</p>
<p>Na linha <code>let mut stdin = termion::async_stdin().keys();</code> criamos um modo <a href="https://en.wikipedia.org/wiki/Async/await" target="_blank">assincrono</a> de capturar as teclas digitadas pelo usuário, utilizando a dependencia do <code>termion</code>, assim que entramos no loop, fazemos as primeiras verificações, que são:</p>
<ul>
<li>Validar se a cabeça da cobra está na mesma posição de um petisco<ul>
<li>Se sim =&gt; seu tamanho aumenta e outro petisco é gerado.</li>
<li>Se não =&gt; valida se a cabeça está na mesma posição de seu corpo<ul>
<li>Se sim =&gt; encerra o jogo com a mensagem de fim de jogo</li>
<li>Se não =&gt; continua a execução</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Então geramos o tabuleiro e armazenamos em uma variável. Com um método do <code>termion</code>, limpamos o terminal, posicionamos o mouse na primeira posição e escondemos o cursor. Logo em sequência desenhamos tabuleiro do jogo. Transformamos a saída em <a href="https://en.wikipedia.org/wiki/Terminal_mode" target="_blank">raw mode</a>, lemos uma tecla e caso alguma tecla tenha sido pressionada validamos qual foi, em um <code>match</code> assim alteramos a direção que a cobra esta andando caso necessário. Limpamos a saída, esperamos meio segundo com o método <code>thread::sleep(Duration::from_milis(500))</code> e então fazemos a cobra dar mais um passo. O processo todo se repete.</p>
<p>Adicionamos a o nosso <code>main</code> a chamada a esse método:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>(){
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Err</span>(msg) = Game::run() {
        eprintln!(<span class="hljs-string">&quot;{}&quot;</span>, msg)
    }
}
</code></pre>
<p>E pronto, temos nosso jogo da cobrinha feito e funcionando, deixo para você os testes finais e adiciono alguns desafios:</p>
<ul>
<li>Faça o jogo pausar</li>
<li>Adicione um placar ao jogo</li>
<li>Quando a cobra alcançar o tamanho máximo (x * y) mostre uma mensagem de vitória e encerre o jogo</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="13-tests.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Testes">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Mini projeto * Snake Game","level":"2.3.14","depth":2,"previous":{"title":"Testes","level":"2.3.13","depth":2,"path":"intermediary-02/13-tests.md","ref":"./intermediary-02/13-tests.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"intermediary-02/14-snake.md","mtime":"2022-03-01T01:43:42.920Z","type":"markdown"},"gitbook":{"version":"3.7.1","time":"2022-05-20T22:57:17.108Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

